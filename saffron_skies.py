# -*- coding: utf-8 -*-
"""Saffron_skies.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19TkQ8wxlwxD3JobzmZDrFw1dQC2YOi-A

Importing the required python libraries
"""

import pandas as pd #basic python library
import seaborn as sns  #data visualisation library
import matplotlib.pyplot as plt  #data visualisation library
import plotly.express as plotx #data visualisation library

"""Uploading the dataset"""

from google.colab import files

uploaded = files.upload()

"""Importing the dataset to the dataframe
Showing the first ten rows of the datset
"""

SAFFRON_SKIES_DATA= pd.read_csv("UK_NATIONAL_AIRLINES_DATA_CW1.csv", encoding="latin-1")
SAFFRON_SKIES_DATA.head(10)

"""Information regarding the dataset"""

SAFFRON_SKIES_DATA.info()

"""Evaluation of the null values in the dataset"""

SAFFRON_SKIES_DATA.isnull().sum()

"""Determination of the duplicate values in the dataset"""

SAFFRON_SKIES_DATA.duplicated().any()

"""Removing the null values"""

SAFFRON_SKIES_DATA.dropna(inplace=True)

"""Descriptive statistics of the dataset"""

SAFFRON_SKIES_DATA.describe()

"""Ploting the relevant variables of the dataset

"""

#Count of Inflight wifi service Ratings based on satisfaction
plot_inflight=sns.countplot(x ='Inflight wifi service', hue= 'Satisfied',data = SAFFRON_SKIES_DATA, palette='Blues')
for label in plot_inflight.containers:
    plot_inflight.bar_label(label)
plt.title('Count of Inflight wifi service Ratings based on satisfaction')
plt.xlabel('Inflight wifi service Rating')
plt.ylabel('Count')
plt.legend(title='Satisfied')
plt.xticks(rotation=30)
plt.tight_layout()
plt.show()

#Determining Satisfaction level by Continent
plot_conti = plotx.histogram(SAFFRON_SKIES_DATA, x='Continent', color='Satisfied', barmode='group',
                   title='Determining Satisfaction level by Continent',
                   labels={'Continent level': 'Continent', 'count of passengers': 'Number of Passengers'})
plot_conti.update_layout(xaxis_title='Continent level', yaxis_title='Count of passengers', bargap=0.3)
plot_conti.show()

#Count of age band based on satisfaction
plot_age=sns.countplot(x ='Age Band', hue= 'Satisfied',data = SAFFRON_SKIES_DATA, palette='husl')
for label in plot_age.containers:
    plot_age.bar_label(label)
plt.title('Count of age band based on satisfaction')
plt.xlabel('Age band')
plt.ylabel('Count')
plt.legend(title='Satisfied')
plt.xticks(rotation=30)
plt.tight_layout()
plt.show()

#Count the type of travel based on satisfaction
plot_type=sns.countplot(x ='Type of Travel', hue= 'Satisfied',data = SAFFRON_SKIES_DATA, palette='coolwarm')  #Count ofType of Travel based on satisfaction
for label in plot_type.containers:
    plot_type.bar_label(label)
plt.title('Count of type of travel based on satisfaction')
plt.xlabel('Type of travel')
plt.ylabel('Count')
plt.legend(title='Satisfied')
plt.xticks(rotation=30)
plt.tight_layout()
plt.show()

"""Data preprocessing"""

#performing data pre-processing
from sklearn.preprocessing import StandardScaler, LabelEncoder
label_encoder_international_dataset = {}
categorical_column_international = ['Gender', 'Satisfied', 'Age Band', 'Type of Travel', 'Class', 'Destination', 'Continent']
for column in categorical_column_international:
    label_encoder_internation= LabelEncoder()
    SAFFRON_SKIES_DATA[column] = label_encoder_internation.fit_transform(SAFFRON_SKIES_DATA[column])
    label_encoder_international_dataset[column] = label_encoder_internation

"""Heatmap generation"""

plt.figure(figsize=(12, 10))
sns.heatmap(SAFFRON_SKIES_DATA.corr(), annot=True, cmap='autumn')
plt.show()

"""Spliting the dataset and fitting the machine learning model"""

from sklearn.model_selection import train_test_split   #Spliting the dataset into two parts

X_international = SAFFRON_SKIES_DATA.drop(['Ref', 'id', 'Satisfied', 'Age'], axis=1)
y_international = SAFFRON_SKIES_DATA['Satisfied']

X_train, X_test, y_train, y_test = train_test_split(X_international, y_international, test_size=0.3, random_state=42)

"""BaggingClassifier model"""

from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import BaggingClassifier
base_model_international = DecisionTreeClassifier()
model_bagging = BaggingClassifier(base_estimator=base_model_international, n_estimators=100)
bag_classifiers = model_bagging.fit(X_train, y_train)

y_pred_bag = bag_classifiers.predict(X_test)

from sklearn.metrics import accuracy_score, log_loss, classification_report, confusion_matrix
accuracy_bagg = accuracy_score(y_test, y_pred_bag)
print("Accuracy of the bagging classifier model:", accuracy_bagg)

print("Classification report of Bagging classifier model:")
print(classification_report(y_test, y_pred_bag))

confusion_matrix= confusion_matrix(y_test, y_pred_bag)
plt.figure(figsize=(5, 4))
sns.heatmap(confusion_matrix, annot=True,
            fmt='g', cmap= 'winter')
plt.title('Confusion Matrix of bagging model')
plt.xlabel('Prediction values',fontsize=12)
plt.ylabel('Actual values',fontsize=12)
plt.show()

Loss_bagg= log_loss(y_test, y_pred_bag)
print(f'Log Loss value of Bagging classifier model: {Loss_bagg:.2f}')

"""ANN Model"""

import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense
ann_model = Sequential([
    Dense(64, activation='relu', input_shape=(X_train.shape[1],)),
    Dense(32, activation='relu'),
    Dense(1, activation='sigmoid')
])

ann_model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])
ann_model.fit(X_train, y_train, epochs=20, batch_size=32, validation_split=0.2, verbose=1)

y_pred_ann = ann_model.predict(X_test)
y_pred_ann = (y_pred_ann > 0.5).astype("int32")

from sklearn.metrics import confusion_matrix
confusion_matrix_ann = confusion_matrix(y_test, y_pred_ann)
plt.figure(figsize=(5, 4))
sns.heatmap(confusion_matrix_ann, annot=True, fmt='g', cmap='spring')
plt.title('Confusion Matrix of ANN model')
plt.xlabel('Predicted values', fontsize=10)
plt.ylabel('Actual values', fontsize=10)
plt.show()

accuracy_ann = accuracy_score(y_test, y_pred_ann)
print(f'Accuracy of ANN model: {accuracy_ann:.3f}')

print(classification_report(y_test, y_pred_ann))

loss_ann= log_loss(y_test, y_pred_ann)
print(f'Log Loss value for ANN: {loss_ann:.3f}')

